# 圣诞节2019 Holy·Samba·Night ～降雪遗迹与少女骑士～ & BATTLE IN NEWYORK 2019
## 自用fgo刷图脚本（mumu模拟器#1280*720，狂兰双CBA换人孔明）
>### 主要 python + opencv + pyside2
- python 简单上手，快速开发
- opencv 可以简单上手并快速开发效果不错的图像识别，同时也作为图像解码
- pyside2 快速实现效果不错的图形界面，附带使用了QT的信号槽通信机制，实现一个线程安全的跨线程UI访问

>### 其他 win32 + subprocess
- win32 用来控制模拟器窗口的自动显示与隐藏
- subprocess 执行终端命令

>## 实现思路
 1. 如何操作模拟器？  
    实现思路有两种，Android本身的无障碍服务、ADB，由于使用无障碍服务还需要开发Android应用，所以这里使用了ADB
 2. 什么时候操作模拟器？  
    一局游戏需要战斗三轮，三轮需要做的事情是一样的，所以这里只需要将相同的事情做三次就好了  
    每轮之间设定一个时间间隔，这样固定的点位点击三次即可  
    这里使用了一点简单的图像识别：模板匹配（实际上这里使用特征识别更好）用于识别游戏场景的开始。这样可以将时间间隔设置短一点，缩短一局游戏的时间  
    图像识别同时也用来作为结算过程的自动跳过和自动吃苹果补充体力。
 3. 怎样获取图像？  
    使用ADB截图命令 `adb exec-out screencap -p`，使用subprocess执行这段指令时将输出指定为当前管道，接收当前数据流并使用opencv解码图片，这样就可以获得一张当前的屏幕截图并且不用保存到磁盘上(用于加速截图的获取)  
    `image_bytes = subprocess.run(["adb", "exec-out", "screencap","-p"], stdout=subprocess.PIPE).stdout`  

>## 一些其他
- 脚本整体有三个线程，UI主线程，游戏线程，和UI截图更新线程
- 战斗开始时自动隐藏模拟器和脚本的UI界面，并在战斗结束时自动弹出  
- 战斗结束时会播放提示音进行提醒
- 战斗过程的日志记录和时长统计

>## 改进点
1. 图像获取方式  
    ADB的图像获取终究还是过于缓慢，如果能实现类似“scrcpy”的方式会更好
2. 战斗的过程  
    虽然近似于自动刷图，但终究不是，助战选择依然需要人工。  
    中途遇到意外导致三回合的节奏中断时，依然需要人工恢复。  
    这也是为什么需要特征识别，模板匹配的局限性太大(如果能由深度学习实现这些就更好了)
3. UI的卡顿  
    UI在战斗过程中还是有一点卡顿，应该是设置图像的耗时太长，导致UI线程卡顿（要解决这一点从图像获取方式上入手最好）
    


